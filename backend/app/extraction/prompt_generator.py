"""Domain prompt generator for adaptive extraction.

This module generates extraction prompts from domain schemas,
filling in entity and relationship type descriptions.

The DomainPromptGenerator takes a DomainSchema and produces:
1. A system prompt with entity/relationship descriptions filled in
2. A JSON schema for structured LLM output validation

Example usage:
    from app.extraction.prompt_generator import (
        DomainPromptGenerator,
        generate_extraction_prompt,
        generate_output_schema,
    )
    from app.extraction.domains import get_domain_schema

    # Get a domain schema
    schema = get_domain_schema("literature_fiction")

    # Option 1: Using the class directly
    generator = DomainPromptGenerator()
    system_prompt = generator.generate_system_prompt(schema)
    json_schema = generator.generate_json_schema(schema)

    # Option 2: Using convenience functions
    system_prompt = generate_extraction_prompt(schema)
    json_schema = generate_output_schema(schema)
"""

from __future__ import annotations

import logging
from typing import Any

from app.extraction.domains.models import DomainSchema

logger = logging.getLogger(__name__)

# Default maximum content length for truncation
DEFAULT_MAX_CONTENT_LENGTH = 8000


class DomainPromptGenerator:
    """Generates extraction prompts from domain schemas.

    The generator takes a domain schema and produces:
    1. A system prompt with entity/relationship descriptions
    2. A JSON schema for structured LLM output

    The system prompt is generated by filling in placeholders in the
    domain's extraction_prompt_template:
    - {entity_descriptions}: Formatted list of entity types
    - {relationship_descriptions}: Formatted list of relationship types
    - {content}: Optional placeholder for content (if using user prompt)

    Attributes:
        max_content_length: Maximum length for content truncation
    """

    def __init__(self, max_content_length: int = DEFAULT_MAX_CONTENT_LENGTH) -> None:
        """Initialize the prompt generator.

        Args:
            max_content_length: Maximum length for content before truncation.
                Defaults to 8000 characters.
        """
        self.max_content_length = max_content_length

    def generate_system_prompt(self, schema: DomainSchema) -> str:
        """Generate extraction system prompt from domain schema.

        Fills in the domain's extraction_prompt_template with formatted
        entity and relationship type descriptions.

        Args:
            schema: The domain schema to generate prompt from.

        Returns:
            Rendered system prompt with entity/relationship descriptions.
        """
        entity_descriptions = self._format_entity_descriptions(schema)
        relationship_descriptions = self._format_relationship_descriptions(schema)

        # Replace placeholders in template
        prompt = schema.extraction_prompt_template
        prompt = prompt.replace("{entity_descriptions}", entity_descriptions)
        prompt = prompt.replace("{relationship_descriptions}", relationship_descriptions)

        logger.debug(
            "Generated system prompt for domain '%s': %d chars",
            schema.domain_id,
            len(prompt),
        )

        return prompt

    def generate_user_prompt(
        self,
        content: str,
        *,
        truncate: bool = True,
    ) -> str:
        """Generate user prompt with content for extraction.

        This creates a user prompt containing the content to extract from.
        Optionally truncates content if it exceeds max_content_length.

        Args:
            content: The content to extract entities/relationships from.
            truncate: Whether to truncate long content. Defaults to True.

        Returns:
            Formatted user prompt with content.
        """
        if truncate and len(content) > self.max_content_length:
            truncated_content = content[: self.max_content_length]
            # Try to truncate at a sentence boundary
            last_period = truncated_content.rfind(". ")
            if last_period > self.max_content_length // 2:
                truncated_content = truncated_content[: last_period + 1]
            truncated_content += "\n\n[Content truncated due to length]"
            logger.debug(
                "Truncated content from %d to %d chars",
                len(content),
                len(truncated_content),
            )
            content = truncated_content

        return f"Extract entities and relationships from the following content:\n\n{content}"

    def _format_entity_descriptions(self, schema: DomainSchema) -> str:
        """Format entity type descriptions for prompt.

        Each entity type is formatted as:
        - **{id}**: {description} (examples: {ex1}, {ex2}, ...)

        Properties are included if present, showing property hints
        to help the LLM understand what to extract.

        Args:
            schema: Domain schema with entity types.

        Returns:
            Formatted entity descriptions string.
        """
        lines = []
        for et in schema.entity_types:
            # Base line with ID and description
            line = f"- **{et.id}**: {et.description}"

            # Add examples if present (limit to 3 for brevity)
            if et.examples:
                examples = ", ".join(et.examples[:3])
                line += f" (examples: {examples})"

            lines.append(line)

            # Add property hints if properties are defined
            if et.properties:
                prop_hints = self._format_property_hints(et.properties)
                if prop_hints:
                    lines.append(f"  Properties: {prop_hints}")

        return "\n".join(lines)

    def _format_property_hints(
        self, properties: list[Any]
    ) -> str:
        """Format property hints for an entity type.

        Args:
            properties: List of PropertySchema objects.

        Returns:
            Formatted property hints string, or empty string if no properties.
        """
        if not properties:
            return ""

        hints = []
        for prop in properties:
            hint = prop.name
            if prop.description:
                hint += f" ({prop.description})"
            hints.append(hint)

        return ", ".join(hints)

    def _format_relationship_descriptions(self, schema: DomainSchema) -> str:
        """Format relationship type descriptions for prompt.

        Each relationship type is formatted as:
        - **{id}**: {description} (from: {sources}; to: {targets})

        Source/target constraints are included to help the LLM
        understand valid relationship patterns.

        Args:
            schema: Domain schema with relationship types.

        Returns:
            Formatted relationship descriptions string.
        """
        lines = []
        for rt in schema.relationship_types:
            line = f"- **{rt.id}**: {rt.description}"

            # Add source/target constraints if specified
            constraints = []
            if rt.valid_source_types:
                constraints.append(f"from: {', '.join(rt.valid_source_types)}")
            if rt.valid_target_types:
                constraints.append(f"to: {', '.join(rt.valid_target_types)}")
            if rt.bidirectional:
                constraints.append("bidirectional")

            if constraints:
                line += f" ({'; '.join(constraints)})"

            lines.append(line)

        return "\n".join(lines)

    def generate_json_schema(self, schema: DomainSchema) -> dict[str, Any]:
        """Generate JSON schema for structured LLM output.

        Creates a JSON Schema that defines the expected structure of
        the LLM's extraction response. Includes:
        - entities array with type enum based on domain entity types
        - relationships array with type enum based on domain relationship types
        - Standard fields: name, type, description, confidence, properties
        - Fallback types: "custom" for entities, "related_to" for relationships

        Args:
            schema: Domain schema to generate JSON schema from.

        Returns:
            JSON Schema dict for LLM response validation.
        """
        # Get entity and relationship type IDs, add fallback types
        entity_type_enum = schema.get_entity_type_ids() + ["custom"]
        relationship_type_enum = schema.get_relationship_type_ids()
        # Ensure related_to is always available as a fallback
        if "related_to" not in relationship_type_enum:
            relationship_type_enum = relationship_type_enum + ["related_to"]

        return {
            "type": "object",
            "properties": {
                "entities": {
                    "type": "array",
                    "description": "Extracted entities from the content",
                    "items": {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "The name or identifier of the entity",
                            },
                            "type": {
                                "type": "string",
                                "enum": entity_type_enum,
                                "description": "The type of entity",
                            },
                            "description": {
                                "type": "string",
                                "description": "A brief description of the entity",
                            },
                            "confidence": {
                                "type": "number",
                                "minimum": 0,
                                "maximum": 1,
                                "description": "Confidence score (0-1)",
                            },
                            "properties": {
                                "type": "object",
                                "description": "Additional entity-specific properties",
                            },
                        },
                        "required": ["name", "type"],
                    },
                },
                "relationships": {
                    "type": "array",
                    "description": "Extracted relationships between entities",
                    "items": {
                        "type": "object",
                        "properties": {
                            "source": {
                                "type": "string",
                                "description": "The name of the source entity",
                            },
                            "target": {
                                "type": "string",
                                "description": "The name of the target entity",
                            },
                            "type": {
                                "type": "string",
                                "enum": relationship_type_enum,
                                "description": "The type of relationship",
                            },
                            "confidence": {
                                "type": "number",
                                "minimum": 0,
                                "maximum": 1,
                                "description": "Confidence score (0-1)",
                            },
                        },
                        "required": ["source", "target", "type"],
                    },
                },
            },
            "required": ["entities", "relationships"],
        }

    def generate_full_prompt(
        self,
        schema: DomainSchema,
        content: str,
        *,
        truncate: bool = True,
    ) -> tuple[str, str]:
        """Generate both system and user prompts for extraction.

        Convenience method that generates both prompts at once.

        Args:
            schema: The domain schema to use.
            content: The content to extract from.
            truncate: Whether to truncate long content. Defaults to True.

        Returns:
            Tuple of (system_prompt, user_prompt).
        """
        system_prompt = self.generate_system_prompt(schema)
        user_prompt = self.generate_user_prompt(content, truncate=truncate)
        return system_prompt, user_prompt


# Singleton instance for convenience functions
_generator: DomainPromptGenerator | None = None


def get_prompt_generator(
    max_content_length: int = DEFAULT_MAX_CONTENT_LENGTH,
) -> DomainPromptGenerator:
    """Get the singleton prompt generator instance.

    Creates the instance on first call. Subsequent calls return
    the same instance.

    Args:
        max_content_length: Maximum content length (only used on first call).

    Returns:
        The singleton DomainPromptGenerator instance.
    """
    global _generator
    if _generator is None:
        _generator = DomainPromptGenerator(max_content_length=max_content_length)
    return _generator


def reset_prompt_generator() -> None:
    """Reset the singleton prompt generator instance.

    Useful for testing to ensure a fresh instance.
    """
    global _generator
    _generator = None


def generate_extraction_prompt(schema: DomainSchema) -> str:
    """Convenience function to generate extraction prompt.

    Args:
        schema: Domain schema to generate prompt from.

    Returns:
        Rendered system prompt.
    """
    return get_prompt_generator().generate_system_prompt(schema)


def generate_output_schema(schema: DomainSchema) -> dict[str, Any]:
    """Convenience function to generate output JSON schema.

    Args:
        schema: Domain schema to generate JSON schema from.

    Returns:
        JSON Schema dict.
    """
    return get_prompt_generator().generate_json_schema(schema)


def generate_user_prompt(
    content: str,
    *,
    truncate: bool = True,
    max_length: int | None = None,
) -> str:
    """Convenience function to generate user prompt with content.

    Args:
        content: Content to extract from.
        truncate: Whether to truncate long content.
        max_length: Maximum content length (uses default if not specified).

    Returns:
        Formatted user prompt.
    """
    generator = get_prompt_generator()
    if max_length is not None:
        # Create a temporary generator with custom max length
        temp_generator = DomainPromptGenerator(max_content_length=max_length)
        return temp_generator.generate_user_prompt(content, truncate=truncate)
    return generator.generate_user_prompt(content, truncate=truncate)
